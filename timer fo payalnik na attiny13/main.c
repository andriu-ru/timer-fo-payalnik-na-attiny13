/*
 * Программа разаработанна для устройства автоматически отключающего нагрузки (паяльник) через определенный промежуток времени.
 * В устройстве предусмотренно 2 временых промежутка на 30 и 60 минут по умолчаню (можно изменить в программе перед заливкой программы в МК).
 * Устройсво управляется двумя кнопками, первая отвечает за пуск 30-и минутного интервала, вторая за 60-и минутный интервал.
 * Если таймер доститал до 97% своего времени прозвучит звуковой сигнал о скогом окончании работы таймера и отключении нагрузки.
 * Работу таймера можно остановить в любой момент, одновременным нажатием на обе кнопки.
 * При работе таймера его работу можно продлить при повнорном нажатии на любую из кнопок и время будет считаться сначала в зависимости от нажатой кнопки.  
 *
 * Программа разработана под Микроконтроллер ATTiny13a.
 *
 * фьюзы: Low:0x69  High:0xFE  (при данной конфигурации фьюзов пятая нога перестает работать как reset и повторное програмированние МК не возможно)
 *
 * Created: 05.04.2020 14:54:06
 * Author : andriu-ru
 */ 

#define F_CPU 37500UL

#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>

unsigned int ui30or60inits = 0; // переменная содержит один из интервалов таймера 30 минут или 60 минут 
unsigned char ucSwithcVariable = 0; // переменная содержит время в секундах до необходимого уровня
unsigned char ucWhileStup = 0; // при помощи данной переменной вгоняем программу в вечный цикл и пока обе кнопки нажаты
float x = 0; // переменная содержит временной интервал для срабатывания зуммера предупреждения о выключении таймера 1 (вычисляется в функции void setupMk(void))
float y = 0; // переменная содержит временной интервал для срабатывания зуммера предупреждения о выключении таймера 1 (вычисляется в функции void setupMk(void))
char a = 0; // обеспечивает однократное выполненение нажатия кнопки 1, повторное выполнение происходит только после отпускния кнопки 1
char b = 0; // обеспечивает однократное выполненение нажатия кнопки 2, повторное выполнение происходит только после отпускния кнопки 2
int c = 0; // переменная нужна для преобразования содержимого переменной "x" из типа данных float в int 
int d = 0; // переменная нужна для преобразования содержимого переменной "y" из типа данных float в int 

#define pauzaStartCPU 100 // данное значение управляет временем паузы перед стартом процессора
#define pauzaBuzzer 50 // данное значение управляет звуковым сигналом перед стартом процессора
#define comparaisonOCR0A 145 // значениие записанное в регистр OCR0A для срабатывания таймера счетчика по совпадению
#define interval_1 1800 // значение временного интервала 1 (30 минут) (при задании временного интервала нужно учитывать погрешность внутреннего RC генератора)
#define interval_2 3600 // значение временного интервала 2 (60 минут) (при задании временного интервала нужно учитывать погрешность внутреннего RC генератора)

ISR(TIM0_COMPA_vect) // вектор прерывания по совпадению с регистром OCR0A
{
		ui30or60inits++; // заходя в прерывание инкрементируем переменнную на 1
		TCNT0 = 0; // обнуляем таймер-счетчик чтобы он считал с начала и мы могли получить интервалы времени равные примерно одной секунде
}
 
 void setupMk(void); // объявляем функцию настройки процессора
 void beeper (char t_sound); // функция отвечает за звуковые сигналы

/************************* Старт программы МК ************************************/

int main(void)
{
	
	setupMk(); // настройка процессора
	
    while (1) 
    {
		
	asm("wdr"); // сброс сторожевого таймера
	
/************************* Код выпоняется при нажатии первой кнопки, запускается таймер первый ************************************/	
	
		if (~PINB & (1<<PB0) && (PINB & (1<<PB1)) && (a == 0)) // считываем состояние 1-й кнопки, ели она нажата выполняется код
		{
			a = 1; // индикатор однркратного нажатия кнопки 1, для того чтобы код ниже сработал повторно кнопку 1 нужно отпустит и нажать повторно
			
			PORTB |= (1<<PB4)|(1<<PB2);
			PORTB &= ~(1<<PB3);
			
			beeper(50); // звук нажатия клавиши 1
						
			ucSwithcVariable = 1; // при нажатии кнопки 1 акивируем 30 минутный таймер
			ui30or60inits = 0;
			TCNT0 = 0;
			
		}
		
/************************* Код выпоняется при нажатии второй кнопки, запускается таймер второй ************************************/
		
		if ((~PINB & (1<<PB1)) && (PINB & (1<<PB0)) && b == 0) // считываем состояние 2-й кнопки, ели она нажата выполняется код
		{
			
			b = 1; // индикатор однркратного нажатия кнопки 2, для того чтобы код ниже сработал повторно кнопку 2 нужно отпустит и нажать повторно
			
			PORTB |= (1<<PB4)|(1<<PB3);
			PORTB &= ~(1<<PB2);
			
			beeper(100); // звук нажатия клавиши 2
			
			ucSwithcVariable = 2; // при нажатии кнопки 2 активируем 60 минутный таймер
			ui30or60inits = 0;
			TCNT0 = 0;
		}
		
/************************* Код выпоняется при нажатии обеих кнопок, остановка обоих таймеров ************************************/
		
		if ((~PINB & (1<<PB1)) && (~PINB & (1<<PB0))) // считываем состояние обеих кнопок, если они нажаты одновременно выполняем код
		{
			ucWhileStup = 1;
			
			PORTB &= ~((1<<PB2)|(1<<PB4)|(1<<PB3));  // сбрасываем все порты в 0
			
			ucSwithcVariable = 0; // отключаем отсчет времени
			
			while(ucWhileStup) // пока обе кнопки нажаты программа находится в данном цикле не ограниченное время
			{
				if ((PINB & (1<<PB1)) && (PINB & (1<<PB0)))
				{
					ucWhileStup = 0;
				}
			}
		 }

/************************* Сброс флагов однократного нажатия кнопок ************************************/

		if ((PINB & (1<<PB1)) && (PINB & (1<<PB0))) // если обе конопки отпущены индикаторы однократного нажатия кнопок сбрасываются в 0
		{
			a = 0;
			b = 0;
		}

/************************* По данному коду выполняется остановка первого таймера ************************************/		
		
		if (ucSwithcVariable == 1) // данный участок кода отвечает за остановку первого таймера
		{			
						
			if (ui30or60inits >= interval_1) // проверяем переменную на равенство первому временному интервалу
			{	
				ucSwithcVariable = 0; // останавливаем счет
				
				PORTB &= ~((1<<PB2)|(1<<PB4)|(1<<PB3)); // сбрасываем все порты в 0
			}
			
			
			
			if (ui30or60inits == c) // если время первого таймера закончилось на 97% звучит предупредительный зуммер
			{
				beeper(50); // предупредительный зуммер об окончании таймера 1
			}
			
		}
		
/************************* По данному коду выполняется остановка второго таймера ************************************/
		
		if (ucSwithcVariable == 2) // данный участок кода отвечает за остановку второго таймера
		{
									
			if (ui30or60inits >= interval_2) // проверяем переменную на равенство второму временному интервалу
			{
				
				ucSwithcVariable = 0; // останавливаем счет
				
				PORTB &= ~((1<<PB2)|(1<<PB4)|(1<<PB3)); // сбрасываем все порты в 0
			}
			
			if (ui30or60inits == d) // если время второго таймера закончилось на 97% звучит предупредительный зуммер
			{
				beeper(50); // предупредительный зуммер об окончании таймера 2
			}
		}
		
    }
	
}




/*******************************************************************************************/
/************************* Функция настройки процессора ************************************/
/*******************************************************************************************/

void setupMk(void) // функция содержит все настройки процессора
{
	/************ настройка пинов процессора ****************/
	
	DDRB &= ~((1<<PB1)|(1<<PB0)); // настраиваем пины 0,1 на вход
	DDRB |= (1<<PB4)|(1<<PB3)|(1<<PB2)|(1<<PB5); // настраиваем пины 2,3,4 на выход (включая ноги ресет)
	
	PORTB |= (1<<PB1)|(1<<PB0); // подаем на пины 0,1 высокий уровень
	PORTB &= ~((1<<PB5)|(1<<PB4)|(1<<PB3)|(1<<PB2)); //подаем на пины 2,3,4 низкий уровень (включая ноги ресет)
	
	/************ настройка делителя частоты МК ****************/
	
	CLKPR=0x80; // настройка делителя частоты МК 128
	CLKPR=0x07; // настройка делителя частоты МК 128
	
	/*
	CLKPR |= (1<<CLKPCE);
	CLKPR |= (1<<CLKPS2)|(1<<CLKPS1)|(1<<CLKPS0);
	CLKPR &= ~(1<<CLKPS3);
	*/
	
	/************ настройка делителя таймера-счетчика ****************/
	
	
	TCCR0B |= (1<<CS02);  // настраиваем делитель таймера-счетчика. коэффициент деления 256.
	TCCR0B &= ~(1<<CS01)|(1<<CS00); // настраиваем делитель таймера-счетчика. коэффициент деления 256.
	
		
	TIMSK0 |= (1<<OCIE0A); // разрешаем прерывание по совпадению
	OCR0A = comparaisonOCR0A; // в регистр сравнения записываем число позволяющее получить 1 секунду пи совпадении ТС

	WDTCR=0x1F; // сторожевой таймер настроен на 2 секунды
	WDTCR=0x0F; // сторожевой таймер настроен на 2 секунды

    x = interval_1; // расчитываем время первого таймра чтобы подать предупредительный сигнал о скором окончании счета первого таймера
	x = x * 97 / 100;
	c = x;
	
	y = interval_2;  // расчитываем время второго таймра чтобы подать предупредительный сигнал о скором окончании счета второго таймера
	y = y * 97 / 100;
	d = y;
	
	
	_delay_ms(pauzaStartCPU); // пауза старта процессора
	
	/*
	PORTB |= (1<<PB5); // сигнал запуска устройства
	_delay_ms(pauzaBuzzer); // сигнал запуска устройства
	PORTB &= ~(1<<PB5); // сигнал запуска устройства
	*/
	
	beeper(50);
	
	sei(); // разрешаем глобальное прерывание
	TCNT0 = 0; // регистр счета таймера-счетчика сбрасываем в 0
	
	
}

/************************************************************************************************************************************/
/************************* функция звукового сигнала, зуммер подключается на прот PB5 нога RESET ************************************/
/************************************************************************************************************************************/

void beeper (char t_sound) // функция отвечает за звуковые сигналы
{
	for (char i=0; i<t_sound; i++)
	{
		PORTB ^= (1<<PB5);
		_delay_ms(1);
	}
}